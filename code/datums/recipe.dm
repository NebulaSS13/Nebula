/* * * * * * * * * * * * * * * * * * * * * * * * * *
 * /datum/recipe by rastaf0            13 apr 2011 *
 * /decl/recipe by Neb                 21 may 2021 *
 *                                                 *
 * Happy tenth birthday you pile of spaghetti!     *
 * * * * * * * * * * * * * * * * * * * * * * * * * */

/decl/recipe
	var/display_name              // Descriptive name of the recipe, should be unique to avoid codex pages being unsearchable.
	var/list/reagents             // example: = list(/decl/material/liquid/drink/juice/berry = 5) // do not list same reagent twice
	var/list/items                // example: = list(/obj/item/crowbar, /obj/item/welder, /obj/item/screwdriver = 2) // place /foo/bar before /foo
	var/list/fruit                // example: = list("fruit" = 3)
	var/result                    // example: = /obj/item/chems/food/donut/normal
	var/time = 100                // Cooking time in deciseconds.
	var/result_quantity = 1       // How many items to create. Where possible, just use fewer ingredients instead.

	var/const/REAGENT_REPLACE = 0 //Reagents in the ingredients are discarded (only the reagents present in the result at compiletime are used)
	var/const/REAGENT_MAX     = 1 //The result will contain the maximum of each reagent present between the two pools. Compiletime result, and sum of ingredients
	var/const/REAGENT_MIN     = 2 //As above, but the minimum, ignoring zero values.
	var/const/REAGENT_SUM     = 3 //The entire quantity of the ingredients are added to the result

	var/reagent_mix = REAGENT_MAX //How to handle reagent differences between the ingredients and the results

	var/complexity                // AUTOGENERATED, DO NOT SET

	// Codex entry values.
	var/hidden_from_codex // If TRUE, codex page will not be generated for this recipe.
	var/lore_text         // IC description of recipe/food.
	var/mechanics_text    // Mechanical description of recipe/food.
	var/antag_text        // Any antagonist-relevant stuff relating to this recipe.

/decl/recipe/Initialize()
	. = ..()
	complexity = length(reagents) + length(fruit)
	var/value
	for(var/i in items) // add the number of items total
		value = items[i]
		complexity += isnum(value) ? value : 1
	complexity += length(uniquelist(items)) // add how many unique items there are; will prioritise burgers over 2 bunbuns and 1 wasted meat, for example

/decl/recipe/proc/check_reagents(var/datum/reagents/avail_reagents)
	SHOULD_BE_PURE(TRUE)
	if(length(avail_reagents?.reagent_volumes) < length(reagents))
		return FALSE
	for(var/rtype in reagents)
		if(REAGENT_VOLUME(avail_reagents, rtype) < reagents[rtype])
			return FALSE
	return TRUE

/decl/recipe/proc/check_fruit(var/obj/container)
	SHOULD_BE_PURE(TRUE)
	if(!length(fruit))
		return TRUE
	var/container_contents = container?.get_contained_external_atoms()
	if(length(container_contents) < length(fruit))
		return FALSE
	var/list/needed_fruits = fruit.Copy()
	for(var/obj/item/chems/food/S in container_contents)
		var/use_tag
		if(istype(S, /obj/item/chems/food/grown))
			var/obj/item/chems/food/grown/G = S
			if(!G.seed || !G.seed.kitchen_tag)
				continue
			use_tag = G.dry ? "dried [G.seed.kitchen_tag]" : G.seed.kitchen_tag
		else if(istype(S, /obj/item/chems/food/fruit_slice))
			var/obj/item/chems/food/fruit_slice/FS = S
			if(!FS.seed || !FS.seed.kitchen_tag)
				continue
			use_tag = "[FS.seed.kitchen_tag] slice"
		use_tag = "[S.dry ? "dried " : ""][use_tag]"
		if(isnull(needed_fruits[use_tag]))
			continue
		needed_fruits[use_tag]--
	for(var/ktag in needed_fruits)
		if(needed_fruits[ktag] > 0)
			return FALSE
	return TRUE

/decl/recipe/proc/check_items(var/obj/container)
	SHOULD_BE_PURE(TRUE)
	if(!length(items))
		return TRUE
	var/list/container_contents = container?.get_contained_external_atoms()
	if(length(container_contents) < length(items))
		return FALSE
	var/list/needed_items = items.Copy()
	for(var/itype in needed_items)
		for(var/thing in container_contents)
			if(!istype(thing, itype))
				continue
			container_contents -= thing
			if(isnum(needed_items[itype]))
				--needed_items[itype]
				if(needed_items[itype] <= 0)
					needed_items -= itype
			else
				needed_items -= itype
			break
		if(!length(container_contents))
			break
	return !length(needed_items)

//general version
/decl/recipe/proc/make(var/obj/container)
	var/obj/result_obj = new result(container)
	var/list/contained_atoms = container.get_contained_external_atoms()
	if(contained_atoms)
		contained_atoms -= result_obj
		for(var/obj/O in contained_atoms)
			O.reagents.trans_to_obj(result_obj, O.reagents.total_volume)
			qdel(O)
	container.reagents.clear_reagents()
	return result_obj

// food-related
/decl/recipe/proc/make_food(var/obj/container)
	if(!result)
		log_error("<span class='danger'>Recipe [type] is defined without a result, please bug this.</span>")
		return
	/*
	We will subtract all the ingredients from the container, and transfer their reagents into a holder
	We will not touch things which are not required for this recipe. They will be left behind for the caller
	to decide what to do. They may be used again to make another recipe or discarded, or merged into the results,
	thats no longer the concern of this proc
	*/
	var/datum/reagents/buffer = new /datum/reagents(1e12, global.temp_reagents_holder)//
	var/list/container_contents = container.get_contained_external_atoms()
	//Find items we need
	if (LAZYLEN(items))
		for (var/i in items)
			var/obj/item/I = locate(i) in container_contents
			if (I && I.reagents)
				I.reagents.trans_to_holder(buffer,I.reagents.total_volume)
				qdel(I)

	//Find fruits
	if (LAZYLEN(fruit))
		var/list/checklist = list()
		checklist = fruit.Copy()

		for(var/obj/item/chems/food/grown/G in container_contents)
			if(!G.seed || !G.seed.kitchen_tag || isnull(checklist[G.seed.kitchen_tag]))
				continue

			if (checklist[G.seed.kitchen_tag] > 0)
				//We found a thing we need
				checklist[G.seed.kitchen_tag]--
				if (G && G.reagents)
					G.reagents.trans_to_holder(buffer,G.reagents.total_volume)
				qdel(G)

	//And lastly deduct necessary quantities of reagents
	if (LAZYLEN(reagents))
		for (var/r in reagents)
			//Doesnt matter whether or not there's enough, we assume that check is done before
			container.reagents.trans_type_to_holder(buffer, r, reagents[r])

	/*
	Now we've removed all the ingredients that were used and we have the buffer containing the total of
	all their reagents.
	If we have multiple results, holder will be used as a buffer to hold reagents for the result objects.
	If, as in the most common case, there is only a single result, then it will just be a reference to
	the single-result's reagents
	*/
	var/datum/reagents/holder = new/datum/reagents(INFINITY, global.temp_reagents_holder)
	var/list/results = list()
	for (var/_ in 1 to result_quantity)
		var/obj/result_obj = new result(container)
		results.Add(result_obj)

		if (!result_obj.reagents)//This shouldn't happen
			//If the result somehow has no reagents defined, then create a new holder
			result_obj.create_reagents(buffer.total_volume*1.5)

		if (result_quantity == 1)
			qdel(holder)
			holder = result_obj.reagents
		else
			result_obj.reagents.trans_to_holder(holder, result_obj.reagents.total_volume)


	switch(reagent_mix)
		if (REAGENT_REPLACE)
			//We do no transferring
		if (REAGENT_SUM)
			//Sum is easy, just shove the entire buffer into the result
			buffer.trans_to_holder(holder, buffer.total_volume)
		if (REAGENT_MAX)
			//We want the highest of each.
			//Iterate through everything in buffer. If the target has less than the buffer, then top it up
			for (var/_R in buffer.reagent_volumes)
				var/rvol = REAGENT_VOLUME(holder, _R)
				var/bvol = REAGENT_VOLUME(buffer, _R)
				if (rvol < bvol)
					//Transfer the difference
					buffer.trans_type_to_holder(holder, _R, bvol-rvol)

		if (REAGENT_MIN)
			//Min is slightly more complex. We want the result to have the lowest from each side
			//But zero will not count. Where a side has zero its ignored and the side with a nonzero value is used
			for (var/_R in buffer.reagent_volumes)
				var/rvol = REAGENT_VOLUME(holder, _R)
				var/bvol = REAGENT_VOLUME(buffer, _R)
				if (rvol == 0) //If the target has zero of this reagent
					buffer.trans_type_to_holder(holder, _R, bvol)
					//Then transfer all of ours

				else if (rvol > bvol)
					//if the target has more than ours
					//Remove the difference
					holder.remove_reagent(_R, rvol-bvol)

	if (length(results) > 1)
		//If we're here, then holder is a buffer containing the total reagents for all the results.
		//So now we redistribute it among them
		var/total = holder.total_volume
		for (var/i in results)
			var/atom/a = i //optimisation
			holder.trans_to(a, total / length(results))
	return results